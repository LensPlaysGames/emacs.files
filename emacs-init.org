#+title: Lens' Emacs Configuration
#+author: Rylan Lens Kellogg
#+description: A literate Emacs configuration file.
#+created: <2022-06-26 Sun>
#+startup: content
#+options: num:nil toc:nil
#+toc: headlines 3

** EmacsClient

While everything possible is done to reduce startup/load times,
there is a newer feature of Emacs that allows for near-instant startup.
It would be kind of silly to not take advantage of it.

That feature is ~emacsclient~.

Use the following command to launch Emacs instead of the regular way;
it will connect to an existing server, or create one if it doesn't exist.

#+begin_src shell :results none
  emacsclient -n -c -a ""
#+end_src

This works amazingly, allowing for near-instantaneous opening of Emacs after the first time.

On Windows, use ~emacsclientw.exe~, and create a shortcut to it with the arguments listed above.


** CapsLock to Ctrl rebind

I don't use this on my desktop, but on laptops I prefer this keybinding.

I use Windows, so AutoHotkey seems like my best solution.

See [[https://www.devdungeon.com/content/rebind-caps-lock-key-escapecontrol#toc-3][this page]] for help on other platforms.

Here's the autohotkey script I use.
#+begin_src text :tangle no
  Capslock::LCtrl
#+end_src


** Installation

To install the new configuration, and backup the old one in
the ~backup~ subdirectory, evaluate the following within Emacs.

Execute source block under point in ~org-mode~ using ~org-babel~:
- ~C-c C-c~
- ~C-c C-v C-e~
- ~M-x org-babel-execute-maybe RET~

#+name: install
#+begin_src emacs-lisp :dir . :results none
  ;; Settings to configure.
  (defvar emacs-init/use-every-package t)

  ;; Backup current Emacs configuration (only things that may be over-written).
  (message "Backing up current config...")
  (let* ((time-string (format-time-string "%Y-%m-%d-%H-%M-%S"))
     (backup-dir (expand-file-name time-string "backup"))
     (custom-user-init-file (expand-file-name "my-init.el" user-emacs-directory)))
    (message "Backing up Emacs configuration to %s..." backup-dir)
    (make-directory backup-dir t)
    ;; The user init file isn't present on a fresh Emacs.
    (when (file-exists-p user-init-file)
      (copy-file user-init-file (expand-file-name ".emacs" backup-dir)))
    (when (file-exists-p custom-user-init-file)
      (copy-file custom-user-init-file (expand-file-name "my-init.el" backup-dir) t))
    (copy-directory user-emacs-directory
            (expand-file-name ".emacs.d" backup-dir)
            nil t t))
  (message "Tangling into Elisp...")
  (let ((generated-files (append
              (org-babel-tangle-file "my-init.org")
              (org-babel-tangle-file "emacs-init.org")))
    (generated-packages (mapcar (lambda (file-path) (car (org-babel-tangle-file file-path)))
                    (directory-files "packages" t "\\.org$")))
    (generated-themes (mapcar (lambda (file-path) (org-babel-tangle-file file-path))
                  (directory-files "themes" t "\\.org$"))))
    (message "Installing new configuration...")

    ;; Copy user init files.
    (copy-file ".emacs" user-init-file t)
    (copy-file "my-init.el" (expand-file-name "my-init.el" user-emacs-directory) t)

    (message "Installing packages...")
    ;; Create `.emacs.d/lisp/` directory if it doesn't already exist.
    (unless (file-exists-p (expand-file-name "lisp" user-emacs-directory))
      (make-directory (expand-file-name "lisp" user-emacs-directory)))
    (dolist (package (directory-files "packages" t "\\.el$"))
      (let ((package-install-path (expand-file-name
                   (file-name-nondirectory package)
                   (expand-file-name "lisp" user-emacs-directory))))
    (copy-file package package-install-path t)
    (byte-compile-file package-install-path)
    ))
    (dolist (generated-package generated-packages)
      (when (file-exists-p generated-package)
    (let ((package-install-path (expand-file-name
                     (file-name-nondirectory generated-package)
                     (expand-file-name "lisp" user-emacs-directory))))
      (princ generated-package)
      (copy-file generated-package package-install-path t)
      (when (string-suffix-p ".el" package-install-path)
        (byte-compile-file package-install-path))
      )))

    (message "Installing themes...")
    (dolist (theme (directory-files "themes" t "\\.el$"))
      (let ((theme-install-path (expand-file-name
                 (file-name-nondirectory theme)
                 user-emacs-directory)))
    (copy-file theme theme-install-path t)))
    (dolist (generated-theme generated-themes)
      (when (file-exists-p generated-theme)
    (let ((theme-install-path
           (expand-file-name
        (file-name-nondirectory generated-theme)
        user-emacs-directory)))
      (copy-file generated-theme theme-install-path t))))

    (message "Cleaning generated files...")
    (dolist (generated-file (append generated-files generated-packages generated-themes))
      (when (file-exists-p generated-file)
        (delete-file generated-file))))

  (when (y-or-n-p "Load new configuration?")
    (load user-init-file)))
#+end_src

TODO: Write LISP to restore from a backup.

** ~.emacs~

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; .emacs --- Rylan Lens Kellogg GNU Emacs 29.0.50 configuration file -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; This file was generated automatically from Lens' literate Emacs configuration.

  ;;; Code:
#+end_src

*** Performance tweaks

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Delay garbage collection until after startup.
  (setq gc-cons-threshold-at-startup gc-cons-threshold)
  (setq gc-cons-threshold 104857600)
  (defun lens/restore-gc-cons-threshold ()
    "Restore 'gc-cons-threshold' variable to 'gc-cons-threshold-at-startup'."
    (setq gc-cons-threshold gc-cons-threshold-at-startup)
    (message "gc-cons-threshold restored to %S"
             gc-cons-threshold))
  ;; Restore garbage collection threshold after startup.
  (add-hook 'emacs-startup-hook 'lens/restore-gc-cons-threshold)

  ;; Prevent unwanted runtime builds in gccemacs (native-comp); packages are
  ;; compiled ahead-of-time when they are installed and site files are compiled
  ;; when gccemacs is installed.
  (setq comp-deferred-compilation nil)

  ;; Fix for font-based performance issues (this fixes custom FontForge fonts lagging heavily).
  (setq inhibit-compacting-font-caches t)

  ;; Prevent unnecessary regexp matching when loading files from .emacs.
  (setq file-name-handler-alist-at-startup file-name-handler-alist)
  (setq file-name-handler-alist nil)
  ;; Restore file-name-handler-alist after startup.
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist
                    file-name-handler-alist-at-startup)))
#+end_src

*** Early

**** Utility Functions

These are some very helpful LISP functions that I use.

***** Promote/Demote TeX headings

Search and replace the following, in order.
"\section" -> "\chapter"
"\subsection" -> "\section"
"\subsubsection" -> "\subsection"

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (defun tex-promote-headings ()
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\section") nil t)
        (replace-match "\\chapter" t t))
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\subsection") nil t)
        (replace-match "\\section" t t))
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\subsubsection") nil t)
        (replace-match "\\subsection" t t))
      ))

  (defun tex-demote-headings ()
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\subsection") nil t)
        (replace-match "\\subsubsection" t t))
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\section") nil t)
        (replace-match "\\subsection" t t))
      (beginning-of-buffer)
      (while (re-search-forward (rx line-start "\\chapter") nil t)
        (replace-match "\\section" t t))
      ))
#+end_src

***** Revert buffer without ~yes-or-no-p~

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (defun revert-buffer-no-confirm ()
    (interactive)
    (revert-buffer t t))
#+end_src

[2022-09-17 Sat 16:27]

***** Convert tabs to spaces in entire buffer

For a long time, I would call ~untabify~, thinking that it would
convert all tabs to spaces in current buffer. It doesn't! So this is
the function that functions how I thought the function I was calling
functioned :p. This is really helpful to put in hooks for certain modes
that you do not want any tabs within (like programming modes, for
example).

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (defun untabify-buffer ()
    "Untabify the current buffer."
    (interactive)
    (untabify (point-min) (point-max)))
#+end_src

***** Duplicate Current Line

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Duplicate Line (Thanks to Nate on StackOverflow)
  ;; https://stackoverflow.com/a/88828
  (defun duplicate-line()
    "Duplicate the line where the cursor resides into a newline inserted below it."
    (interactive)
    (eval-when-compile (defvar cursor-point))
    (setq cursor-point (point))
    (move-beginning-of-line)
    (kill-line)
    (yank)
    (open-line)
    (forward-line)
    (yank)
    (goto-char cursor-point)
    (forward-line))
#+end_src

***** Get List of Regexp Matches in Current Buffer

While there is great regular expression support in Emacs out of the box,
there surprisingly isn't really a way to gather an entire list of
matches, and especially not gathering a specific capture group of that.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Thanks to Jordon on StackExchange for the inspiration.
  ;; https://emacs.stackexchange.com/a/7156/37908
  (defun matches-in-buffer (regexp &optional buffer capture-group)
    "Return a list of strings matching REGEXP in BUFFER, \
  or the current buffer if not one is not given.

  If CAPTURE-GROUP is given, it is passed as the \
  NUM argument to 'match-string-no-properties'."
    (let ((matches)
          (cap-group (if capture-group capture-group 0)))
      (save-match-data
        (save-excursion
          (with-current-buffer (or buffer (current-buffer))
            (save-restriction
              (widen)
              (goto-char (point-min))
              (while (re-search-forward regexp nil t 1)
                (push (match-string-no-properties cap-group) matches)))))
        matches)))
#+end_src

***** Custom Line Wrapping (mostly for code comments)

Basically, take the current line and split it into multiple lines
broken before a specific column and between words. Similar to what I do
manually in these org files, and for my code comments.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (defconst wrap-at-column-whitespace "\t\n\r "
    "All characters within this string at end of each line in
  'wrap-at-column' will be removed before creating a new line.")

  (defun wrap-at-column (column &optional prefix word original-point)
    "Wrap current line into multiple that are COLUMN length or under.

      COLUMN is an integer column number to wrap at. Fed directly to 'move-to-column'.
      PREFIX is a string that will be placed at the beginning of each newline.
      When WORD is non-nil, use 'backward-word' instead of the default 'backward-sexp'.
      ORIGINAL-POINT is used internally to restore point; pass nil iff you must."
    (interactive "NWrap at Column: \n")
    (unless original-point
      (setq original-point (point)))
    (beginning-of-line)
    ;; When line contains COLUMN columns...
    (if (= column (move-to-column column))
        (progn
          ;; Unless there is whitespace at COLUMN, skip to beginning of sexp/word.
          (unless (seq-contains wrap-at-column-whitespace (char-before))
            (if word
                (backward-word)
              (backward-sexp)))
          ;; Move behind opening parens/braces/quotes.
          (when (or (eq ?\( (char-before))
                    (eq ?\[ (char-before))
                    (eq ?\{ (char-before)))
            (backward-char))
          ;; Delete whitespace at end of line...
          ;; Delete whitespace forwards...
          (skip-chars-forward wrap-at-column-whitespace)
          ;; Delete whitespace backwards...
          (let ((end (point)))
            (skip-chars-backward wrap-at-column-whitespace)
            (delete-region (point) end))
          (newline)
          (when prefix (insert prefix))
          (wrap-at-column column prefix word original-point))
      (goto-char original-point)))

  (defun wrap-comment (column)
    (interactive "NWrap at Column: \n")
    (wrap-at-column column (concat comment-start " ")))

  (defun lens/wrap-comment ()
    (interactive)
    (let ((original-point (point)))
      (beginning-of-line)
      (beginning-of-line-text)
      (let ((prefix (buffer-substring (line-beginning-position) (point))))
        (wrap-at-column (+ 72 (- (point) (line-beginning-position))) prefix t original-point))))
#+end_src

This is actually incredibly useful, as long comments can be organized
into the proper format just like that. Not to mention the bonus from
writing plain text and being able to cap paragraphs at a certain
length line.

[2022-09-12 Mon 16:26]

***** Disable all themes (they stack)

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Disable all themes (they stack and can only be disabled one-by-one,
  ;; by default)
  (defun disable-all-themes ()
    "Disable all themes found in 'custom-enabled-themes' list variable."
    (interactive)
    ;; TODO: Do I need a defvar for custom-enabled-themes here?
    (mapcar (lambda (x) (disable-theme x)) custom-enabled-themes))
#+end_src

***** Filename-Compatible Timestamp

Timestamps often don't end up in a format that is usable within a
filename; this one is, while still adhering to ISO 8601 specification.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (defun filename-timestamp ()
    "Return a string containing the current time adhering to ISO 8601 format
  while not using any illegal characters in filenames, like `:`."
    (interactive)
    (let ((timestamp-string (format-time-string "%FT%H%M%S%z")))
      (if (called-interactively-p)
          (message "It is currently %s" timestamp-string)
        timestamp-string)))
#+end_src

***** TODO Snake Case to Camel Case Converter

**** Open New Frames in Fullscreen

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Have Emacs open in fullscreen, no window frame.
  ;; NOTE: This may break tools that use new frames (like `ediff`).
  (add-to-list 'default-frame-alist '(fullscreen . fullscreen))
#+end_src

**** Extend lisp source directories

Add ~lisp~ and ~external_lisp~ subdirectories of ~user-emacs-directory~
to the global load path, meaning Elisp may be loaded from them.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Add ability to load files from `~/.emacs.d/lisp` and `~/.emacs.d/external_lisp`.
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
  (add-to-list 'load-path (expand-file-name "external_lisp" user-emacs-directory))
#+end_src

**** Disable unnecessary GUI elements

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Disable unnecessary GUI elements.
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq inhibit-splash-screen t)
  (setq use-file-dialog nil)
#+end_src

**** Initialize Package Management

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Initialize package management

  (eval-when-compile
    (require 'package)
    (setq load-prefer-newer t)
    (setq package-enable-at-startup nil)
    (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")
                             ("org" . "https://orgmode.org/elpa/")))
    (package-initialize)
    ;; use-package bootstrap
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package)
    (setq use-package-always-ensure t)
    ;; use-package depends on bind-key if :bind is used.
    (require 'bind-key))

  ;; Automatically compile Elisp files for all da speedz.
  (use-package auto-compile
    :defer nil
    :config
    (auto-compile-on-load-mode))
#+end_src

**** Load ~my-init~

~my-init~ is tangled from ~my-init.org~, and contains custom
initialization per each machine/user of this Emacs config.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Load user-specific Initialization
  (load (expand-file-name "my-init" user-emacs-directory) t)
#+end_src

*** Packages

NOTE: The packages in the ~packages~ subdirectory automatically
include themselves by default. \
Exclude them by defining ~emacs-init/use-every-package~ to nil.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; icomplete-vertical
  ;; Vertical completions in the minibuffer.
  ;; https://github.com/oantolin/icomplete-vertical
  (use-package icomplete-vertical
    :demand t
    :bind
    (:map icomplete-minibuffer-map
          ("<down>"     . icomplete-forward-completions)
          ("C-n"        . icomplete-forward-completions)
          ("<up>"       . icomplete-backward-completions)
          ("C-p"        . icomplete-backward-completions)
          ("<C-tab>"    . icomplete-force-complete)
          ("<C-return>" . icomplete-force-complete-and-exit))
    :custom-face
    (icomplete-first-match
     ((t (:inherit font-lock-string-face))))
    (completions-first-difference
     ((t (:inherit font-lock-string-face))))
    :custom
    (completion-styles '(partial-completion substring))
    (completion-category-overrides '((file (styles basic substring))))
    (read-file-name-completion-ignore-case t)
    (read-buffer-completion-ignore-case t)
    (completion-ignore-case t)
    :config
    (icomplete-mode)
    (icomplete-vertical-mode))

  ;;; multiple-cursors
  ;; Create multiple cursors within a single buffer.
  ;; https://github.com/magnars/multiple-cursors.el
  (use-package multiple-cursors
    :bind
    (("C->"           . mc/mark-next-like-this)
     ("C-<"           . mc/mark-previous-like-this)
     ("C-?"           . mc/mark-all-like-this)
     ("<C-M-mouse-1>" . mc/add-cursor-on-click)))

  ;;; eglot
  ;; Language server protocol interface.
  ;; Simple and fairly non-intrusive.
  ;; https://github.com/joaotavora/eglot
  (use-package eglot
    :hook
    ((c-mode
      c++-mode
      cmake-mode)
     . eglot-ensure)
    :custom
    (eglot-send-changes-idle-time 0))

  ;;; magit
  ;; Magic git integration.
  ;; https://magit.vc/
  (use-package magit
    :defer t)

  ;;; smartparens
  ;; I use this over the built-in `electric-pair-mode` due to it
  ;; automatically handling escaped characters within pairs very well.
  ;; https://github.com/Fuco1/smartparens
  (use-package smartparens
    :config
    (smartparens-global-mode t))

  ;;; which-key
  ;; When a key chord is pressed but not yet completed, a list of completions is shown.
  ;; https://github.com/justbur/emacs-which-key
  (use-package which-key
    :config
    (which-key-mode t))

  ;;; yasnippet
  ;; Insert templated snippets of text at point.
  (use-package yasnippet-snippets
    :defer t)
  (use-package yasnippet
    :defer t
    :bind
    (("C-'" . yas-insert-snippet))
    :config
    (yas-global-mode 1))

  ;;; move-text
  ;; Move a line or region of text up or down through a file.
  ;; I only ever use it to move single lines, but it is very helpful.
  ;; NOTE: org-mode shadows these keybindings, so maybe choose
  ;; something else? Or just bind other keys in org-mode.
  ;; https://github.com/emacsfodder/move-text
  (use-package move-text
    :bind
    (("M-p" . 'move-text-up)
     ("M-n" . 'move-text-down))
    )

  ;; TODO and FIXME highlighting.
  ;; https://github.com/lewang/fic-mode
  (use-package fic-mode
    :hook
    ((prog-mode) . fic-mode)
    :custom-face
    (fic-face
     ((t (:background
          nil
          :foreground
          nil
          :underline
          (:color "red" :style wave)
          )))))

  ;;; uptimes
  ;; Record Emacs session uptimes.
  (use-package uptimes)

  ;;; esup
  ;; Emacs startup should be fast! But why is it slow? Hard to know.
  ;; That's where esup comes in handy: The Emacs StartUp Profiler.
  ;; Thanks to https://github.com/jschaf/esup/issues/54#issuecomment-651247749
  ;; https://github.com/jschaf/esup
  (use-package esup
    :commands esup
    :config
    (setq esup-depth 0))
#+end_src

**** Completion

I used to use ~company-mode~ and activate it manually, but now I use corfu + cape.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; corfu
  ;; https://github.com/minad/corfu
  (use-package corfu
    ;; Optional customizations
    :custom
    (corfu-auto t)
    (corfu-auto-prefix 1)
    (corfu-auto-delay 0)
    (corfu-preview-current t)
    (corfu-preselect 'first)
    (corfu-popupinfo-delay 0.2)

    :config
    ;; Enable Corfu globally.
    (global-corfu-mode 1)
    (corfu-popupinfo-mode 1)
    ;; Corfu annoyingly rebinds beginning-of-line and end-of-line. No bueno.
    (keymap-unset corfu-map "<remap> <move-beginning-of-line>" t)
    (keymap-unset corfu-map "<remap> <move-end-of-line>" t))

  (defun lens/cape-capf-prog-setup ()
    "Setup 'completion-at-point-functions' for programming derived modes."
    (add-to-list 'completion-at-point-functions 'cape-file)
    (add-to-list 'completion-at-point-functions 'cape-keyword))

  (defun lens/cape-capf-org-setup ()
    "Setup 'completion-at-point-functions' for 'org-mode'."
    (add-to-list 'completion-at-point-functions 'cape-elisp-block))

  (setq-default completion-at-point-functions '(cape-dabbrev))

  ;;; cape
  ;; https://github.com/minad/cape
  (use-package cape
    :custom
    (cape-dabbrev-min-length 0)
    (cape-dabbrev-check-other-buffers nil)
    :hook
    (prog-mode . lens/cape-capf-prog-setup)
    (org-mode . lens/cape-capf-org-setup)
    :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster))
#+end_src

**** Language Support

***** Assembly

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; GNU Assembly (GAS)
  ;; asm-mode is a built-in, but it has a terrible,
  ;; terrible comment command that must be rebound.
  (use-package asm-mode
    :pin manual
    :ensure nil
    :bind
    (:map asm-mode-map
          (";" . nil)
          (":" . self-insert-command))
    :mode
    ("\\.s\\|.S\\'" . asm-mode))
  ;; The above regexp matches .emacs, we have to explicitly handle it.
  ;; Add .emacs to auto-mode-alist.
  (add-to-list 'auto-mode-alist '("\\.emacs\\'" . emacs-lisp-mode))

  ;;; Netwide Assembly (NASM)
  ;; https://nasm.us/
  (use-package nasm-mode
    :bind
    (:map nasm-mode-map
          (";" . self-insert-command))
    :mode
    ("\\.nasm\\|.asm\\'" . nasm-mode))
#+end_src

***** D

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; D
  ;; https://dlang.org/
  (use-package d-mode
    :mode
    ("\\.d\\'" . d-mode))
#+end_src

***** Markdown

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Markdown
  ;; Major mode for editing Markdown.
  ;; https://github.com/jrblevin/markdown-mode
  (use-package markdown-mode
    :mode
    ("\\.md\\'" . gfm-mode)
    :hook
    ((markdown-mode) .
     (lambda ()
       outline-minor-mode
       ))
    :custom-face
    (markdown-code-face ((t (:inherit default)))))

#+end_src

***** Meson

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Meson build files
  ;; https://mesonbuild.com/
  ;; https://github.com/mesonbuild/meson
  (use-package meson-mode
    :mode
    ("\\meson.build\\|.meson\\'" . meson-mode))
#+end_src

***** Rust

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Rust
  ;; https://www.rust-lang.org/
  (use-package rust-mode
    :mode
    ("\\.rs\\'" . rust-mode))
#+end_src

***** Zig

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Zig
  ;; https://ziglang.org/
  (use-package zig-mode
    :mode
    ("\\.zig\\'" . zig-mode))
#+end_src

***** EBNF

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; EBNF -- Extended Backus-Naur Form
  ;; https://github.com/nverno/ebnf-mode
  (use-package ebnf-mode
    :mode
    ("\\.bnf\\'" . ebnf-mode))
#+end_src


**** A e s t h e t i c

***** Ligatures

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (use-package ligature
    :config
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures 't '("www" "?!" "ae" "ff" "fi" "fl" "ft" "ffl" "ffi" "ct" "fs" "st" "sp" "fj" "fk" "ij" "Th" "ct" "ck" "oo" "TT" "LL"))
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "->" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers.
    (global-ligature-mode t)
    )
#+end_src

***** Fixed-pitch Fix

I hate how fixed-pitch fonts look in Emacs, and it isn't needed when
using a monospace font, anyway.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; Fixed-pitch face fix
  (set-face-attribute
   'fixed-pitch nil
   :family 'unspecified
   :foundry 'unspecified
   :foreground 'unspecified
   :background 'unspecified)
  (set-face-attribute
   'fixed-pitch-serif nil
   :family 'unspecified
   :foundry 'unspecified
   :foreground 'unspecified
   :background 'unspecified)
#+end_src

***** Smooth Scrolling

Smoother scrolling in newer versions of Emacs.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Smoother scrolling on newer Emacs
  ;; TODO: Test out `good-scroll.el`
  (when (>= emacs-major-version 29)
    (pixel-scroll-mode t)
    (pixel-scroll-precision-mode t)
    (push 2 mouse-wheel-scroll-amount)
    (setq mouse-wheel-progressive-speed nil)
    (setq pixel-resolution-fine-flag t)
    (setq pixel-dead-time 0.16)
    (keymap-global-set "C-v" 'pixel-scroll-interpolate-down)
    (keymap-global-set "M-v" 'pixel-scroll-interpolate-up))
#+end_src

***** C++ Integer Qualifier Highlighting

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; modern-cpp-font-lock
  ;; Better syntax highlighting for C++ source code.
  ;; TODO: Leverage infix face for constants like `nullptr`.
  ;; https://github.com/ludwigpacifici/modern-cpp-font-lock
  (defface modern-c++-integer-base-face
    `((t (:foreground "#47afff")))
    "The face that will highlight things like `0x`, `0b`, `ull`, etc.")
  (use-package modern-cpp-font-lock
    :hook
    ((c++-mode) . #'modern-c++-font-lock-mode)
    :custom
    (modern-c++-literal-binary-prefix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-octal-prefix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-dec-prefix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-hex-prefix-face 'modern-c++-integer-base-face)
    ;;(modern-c++-literal-binary-infix-face 'modern-c++-integer-base-face)
    ;;(modern-c++-literal-octal-infix-face 'modern-c++-integer-base-face)
    ;;(modern-c++-literal-dec-infix-face 'modern-c++-integer-base-face)
    ;;(modern-c++-literal-hex-infix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-binary-suffix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-octal-suffix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-dec-suffix-face 'modern-c++-integer-base-face)
    (modern-c++-literal-hex-suffix-face 'modern-c++-integer-base-face)
    :config
    (setq modern-c++-font-lock-literal-integer nil))
#+end_src

***** CMake Syntax Highlighting

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; cmake-font-lock
  ;; Better syntax highlighting for CMake scripts.
  ;; https://github.com/Lindydancer/cmake-font-lock
  (use-package cmake-font-lock
    :defer t)
#+end_src

***** EShell Syntax Highlighting

If a command is valid, it's green. If not, it's red. It's unbelievable
how useful and valuable this simple feature is.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; eshell-syntax-highlighting
  ;; Syntax highlight commands on the EShell command line.
  ;; https://github.com/akreisher/eshell-syntax-highlighting
  (use-package eshell-syntax-highlighting
    :hook
    ((eshell-mode) . eshell-syntax-highlighting-mode)
    :custom-face
    (eshell-prompt ((t (:foreground "#7c8085")))))
#+end_src

***** Centered Text Body

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;;; olivetti
  ;; Move the body of text of a window to the center; good for writing vs code.
  ;; https://github.com/rnkn/olivetti
  (use-package olivetti
    :commands olivetti-mode
    :custom
    (olivetti-body-width 88))
#+end_src

**** Meaningless Fun

2048, but implemented entirely in Emacs!

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; 2048 -- like that phone game
  (use-package 2048-game
    :defer t
    :commands (2048-game))
#+end_src

Emacs has a +yule-log+ mode-line burning, and it smells like napalm!

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; A cozy fireplace for Emacs
  ;; https://github.com/johanvts/emacs-fireplace/
  (use-package fireplace
    :defer t
    :commands (fireplace))
#+end_src

***** Zone Out

Zone out after three minutes!
This uses the built-in ~zone~ package.

This broke for me, in GNU Emacs 30.0.50 (build 1, x86_64-w64-mingw32),
with the error message: "Error (use-package): Cannot load zone".
Solution is to disable on versions 29 and newer, as the last one that
worked was in Emacs 28.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  (when (< emacs-major-version 29)
    (use-package zone-rainbow
      :defer t
      :commands (zone-pgm-rainbow))
    (use-package zone-sl
      :defer t
      :commands (zone-pgm-sl))
    (use-package zone
      :config
      (defun zone-choose (pgm)
        "Choose a zone program to run from zone-programs list."
        (interactive
         (list
          (completing-read
           "Program: "
           (mapcar 'symbol-name zone-programs))))
        (let ((zone-programs (list (intern pgm))))
          (zone)))
      ;; Use a subset of the default programs.
      (setq zone-programs
            [zone-pgm-drip
             zone-pgm-explode
             zone-pgm-paragraph-spaz
             zone-pgm-putz-with-case
             zone-pgm-2nd-putz-with-case
             zone-pgm-rainbow
             zone-pgm-stress-destress
             zone-pgm-sl])
      ;; After three minutes of being idle, zone out.
      (zone-when-idle 180)))
#+end_src


*** Late

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Show trailing whitespace highlighted in red.
  (setq show-trailing-whitespace t)

  ;; Auto-revert to disk on file change globally.
  (global-auto-revert-mode t)

  ;; Display line numbers in left fringe.
  (setq display-line-numbers-width-start t)
  (global-display-line-numbers-mode t)

  ;; Soft word wrap
  (setq-default word-wrap t)

  ;; Don't insert a tab when indenting.
  (setq-default indent-tabs-mode nil)

  ;; A tab is equal to four spaces.
  (setq-default tab-width 4)

  ;; No alarm bells!
  (setq ring-bell-function 'ignore)

  ;; Larger history for shell commands.
  (setq comint-input-ring-size 1024)
  (setq eshell-history-size 1024)

  ;; Disable undo in shell mode.
  (add-hook 'shell-mode-hook 'buffer-disable-undo)

  ;; Disable built-in parentheses highlighting.
  (setq show-paren-mode nil)

  ;; Disable blinking cursor.
  (blink-cursor-mode 0)

  ;; Disable built-in version control (Magit is enough)
  (setq vc-handled-backends nil)
#+end_src

**** Cursor customization

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Make the cursor stretch to cover wide characters, like tab. This
  ;; makes them easier to see, without having to resort to whitespace
  ;; mode.
  (setq x-stretch-cursor t)
#+end_src


**** Show trailing whitespace

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Show extra whitespace at the end of a line very clearly.
  (setq-default show-trailing-whitespace t)
#+end_src

**** Report Startup Time

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Show startup time.
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs loaded in %s with %d garbage collections."
                       (format "%.2fs" (float-time (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

**** Compilation

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Display compilation buffer in a thin side window on the very right.
  (push
   `("\\*compilation\\*"
     (display-buffer-in-side-window)
     (window-width . 0.18)
     (side . right)
     (slot . 1)
     (window-parameters
      (mode-line-format . ("" " %b"))))
   display-buffer-alist)

  ;; Scroll `*compilation*` buffer automatically.
  (setq compilation-scroll-output t)

  ;; Do not ask a million times if I'd like to save my files when compiling >:|
  ;; Shoutout to TTV@Aruseus for this amazing quick tip :^)
  (setq compilation-ask-about-save nil)

  ;; Always kill a running compilation with a new compilation.
  (setq compilation-always-kill t)
#+end_src

**** Customize Emacs file backups

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs

  ;; Save all backups in `~/.emacs.d/backup/` directory.
  (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
        backup-by-copying t
        version-control t
        delete-old-versions t
        kept-new-versions 15
        kept-old-versions 10)
#+end_src

**** Native/Byte Compilation warnings

Disable some warning types for byte compilation, as they can be quite
annoying when a package is installed or updated or when Emacs starts
up, for example.

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Disable some warning types for byte compilation
  ;; Use `M-X describe-variable byte-compile-warnings` for more info
  (setq byte-compile-warnings '(not docstrings free-vars))
#+end_src

**** Set default file encoding (UTF-8)

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; Default file encoding of UTF-8.
  (set-language-environment "UTF-8")
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
#+end_src

**** Truncate Long Lines, Don't Wrap

#+begin_src emacs-lisp :mkdirp yes :tangle .emacs
  ;; ARG being positive means to truncate long lines; otherwise, they'd
  ;; be folded
  (toggle-truncate-lines 1)
#+end_src
